import QuantumES as qes
import fitness_functions as test
import pandas as pd
import os.path


def write(dim, n_iter=10,
          directory='experiments/test_bianca',
          g=1,
          n_copy=10,
          n_max_evaluations=100,
          shots=1024,
          simulator='qasm',
          noise=False,
          gpu=False,
          obj_function=test.sphere,  # TODO: change
          min_value_gene=-5,
          max_value_gene=5,
          dtheta=0.1,
          action_weights=[50, 10, 10, 30],
          multi_action_pb=0.1,
          max_gen_no_improvements=20, **kwargs):
    """
    This function sets up and runs a series of quantum evolutionary strategy simulations,
    collects data from each run, and then saves this data to a pickle file.
    Its parameters are needed to configure the simulation (e.g., dimensionality of the
    problem, number of iterations) and settings for the quantum part (`shots`, `simulator`,
    `noise`, etc.).

    It writes a pickle file with 6 columns and n_iter rows.
    Each row represent an independent run, while columns are, in order: the best solutions,
    the best quantum circuits, the relative depth, the actions made on the circuits, the best
    fitness values and the final fitness value found. All those variable are list over the
    generations.

    :param directory: string. Path where the file has to be saved
    :param n_iter: integer. Number of independent runs of the algorithm
    :param dim: integer. Problem size
    :param g: integer. Number of garbage qubits
    :param n_copy: integer. Number of individuals generated at each iteration of the evolution strategy
    :param n_max_evaluations: integer. Termination criteria over the number of fitness evaluations
    :param shots: integer. Number of executions on a quantum circuit to get the probability distribution
    :param simulator: string. statevector or qasm # TODO:read into this
    :param noise: Boolean. True if a noisy simulation is required, False otherwise
    :param gpu: True or False. If True, it simulates quantum circuits on GPUs, otherwise it does not
    :param obj_function: string. Name of the objective function to minimize
    :param min_value_gene: float. Lower bound on the domain of the objective function # TODO: change
    :param max_value_gene: float. Upper bound on the domain of the objective function # TODO: change
    :param dtheta: float. Maximum displacement for the angle parameter in the mutation action
    :param action_weights: list of four integers summing to 100 # TODO: look what this is
    :param multi_action_pb: float. Probability to get multiple actions in the same generation
    :param max_gen_no_improvements: integer. Maximum number of generations with no improvements,
                                    then some changes will be applied

    :keyword max_depth: integer. It fixes an upper bound on the quantum circuits depth"""

    data = []  # Initialize an empty list to store data from each run
    for depth in kwargs.values():  # Extract argument max_depth from additional kwargs if provided
        max_depth = depth
    for i in range(n_iter):  # Loop over the number of independent runs
        print('independent run number:', i)  # Printing the current run number
        #  Append data generated by QES for each run (calling QES to generate the data)
        data.append(qes.Qes(dim=dim, g=g, n_copy=n_copy, n_max_evaluations=n_max_evaluations, shots=shots,
                            simulator=simulator, noise=noise, gpu=gpu, obj_function=obj_function,
                            min_value_gene=min_value_gene,
                            max_value_gene=max_value_gene, dtheta=dtheta, action_weights=action_weights,
                            multi_action_pb=multi_action_pb,
                            max_gen_no_improvement=max_gen_no_improvements, max_depth=max_depth).data().output)
        # Convert the data into a DataFrame for saving
        df = pd.DataFrame(data, columns=['best_sol', 'initial_qc', 'final_qc', 'depth', 'best_actions', 'fitnesses',
                                         'best_fitness'])
        # Get the name of the objective function
        obj_function_name = test.get_variable_name(obj_function)
        # Define file name to save the pickle file
        file_name = os.path.join(directory, obj_function_name + '/' + obj_function_name + '_dim_' + str(dim) + '_g_' +
                                 str(g) + '_' + simulator + '.pkl')
        # Save the DataFrame to a pickle file
        df.to_pickle(os.path.join(file_name))
    # Print a message after saving the file
    return print('file .pkl saved')


DIM = [80]
for d in DIM:  # Looping through each dimension value
    write(dim=d, max_depth=50)  # Calling the write function for each dimension value
