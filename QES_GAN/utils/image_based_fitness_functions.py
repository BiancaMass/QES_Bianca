import numpy as np
import torch
from skimage.metrics import structural_similarity


def calculate_mse(sr_image, target_image):
    """
    Calculate the Mean Squared Error (MSE) between two images or batches of images.
    The function accepts both tensors and numpy arrays. If tensors, it converts them to numpy
    arrays before calculating the MSE. The function can handle both single images and batches of
    images.

    MSE between two images is calculated as the squared difference of each HR pixel to each
    corresponding SR pixel, divided by number of pixels (averaged).

    :param sr_image: numpy.ndarray or torch.Tensor. The SR image(s) generated by the ansatz.
    :param target_image: numpy.ndarray or torch.Tensor. The original HR image(s) (target).

    :returns mse: float. The Mean Squared Error.
    """
    # Convert PyTorch tensors to NumPy arrays if necessary
    if isinstance(sr_image, torch.Tensor):
        # If tensor is on GPU, transfer to CPU
        # Needed because NumPy does not support GPU tensors directly.
        sr_image = sr_image.detach().cpu().numpy()
    if isinstance(target_image, torch.Tensor):
        target_image = target_image.detach().cpu().numpy()

    # Control for empty images
    if sr_image.size == 0 or target_image.size == 0:
        raise ValueError("One or both images are empty.")

    # Ensure the images have the same shape
    if sr_image.shape != target_image.shape:
        raise ValueError("Images must have the same dimensions.")

    # Calculate MSE
    mse = np.mean((sr_image - target_image) ** 2)

    return mse


def calculate_ssim(sr_image, target_image, batch):
    """
    Calculate the Structural Similatiry Index (SSIM) between two images or batches of images.
    The function accepts both tensors and numpy arrays. If tensors, it converts them to numpy
    arrays before calculating the SSIM. The function can handle both single images and batches of
    images.

    The Structural Similarity Index (SSIM) between two images measures the similarity in
    luminance, contrast, and structure, evaluated over local patches, to provide a more
    perceptually relevant assessment than simple pixel-wise differences.

    :param sr_image: numpy.ndarray or torch.Tensor. The SR image(s) generated by the ansatz.
    :param target_image: numpy.ndarray or torch.Tensor. The original HR image(s) (target).
    :param batch: boolean. True if the inputs are batches of images, False if single image.


    :returns mean_ssim: float. The mean structural similarity index over the images.
    """

    # Convert PyTorch tensors to NumPy arrays if necessary
    if isinstance(sr_image, torch.Tensor):
        # If tensor is on GPU, transfer to CPU
        # Needed because NumPy does not support GPU tensors directly.
        sr_image = sr_image.detach().cpu().numpy()
    if isinstance(target_image, torch.Tensor):
        target_image = target_image.detach().cpu().numpy()

    # Control for empty images
    if sr_image.size == 0 or target_image.size == 0:
        raise ValueError("One or both images are empty.")

    # Ensure the images have the same shape
    if sr_image.shape != target_image.shape:
        raise ValueError("Images must have the same dimensions.")

    # For batches
    ssims = []

    if batch:
        # Process each image in the batch
        for i in range(sr_image.shape[0]):
            data_range = max(sr_image[i].max(), target_image[i].max()) - min(sr_image[i].min(),
                                                                             target_image[i].min())
            current_ssim = structural_similarity(im1=sr_image[i],
                                                 im2=target_image[i],
                                                 gradient=False,
                                                 data_range=data_range,
                                                 channel_axis=-1,
                                                 full=False)
            ssims.append(current_ssim)
        mean_ssim = float(np.mean(ssims))
    else:
        # Process a single image
        data_range = max(sr_image.max(), target_image.max()) - min(sr_image.min(),
                                                                   target_image.min())
        mean_ssim = float(structural_similarity(im1=sr_image,
                                                im2=target_image,
                                                gradient=False,
                                                data_range=data_range,
                                                channel_axis=-1,
                                                full=False))

    return mean_ssim
